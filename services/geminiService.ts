
import { GoogleGenAI, GenerateContentResponse } from "@google/genai";
import type {
  ParaphraseResponse,
  AIContentDetectionResult,
  DetectAIContentServiceResult,
  PlagiarismDetectionResult,
  FindPlagiarismServiceResult,
  Candidate,
  GroundingChunk,
  WebSource
} from '../types';

// API key is sourced directly from process.env.API_KEY per guidelines.
const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
const GEMINI_MODEL = "gemini-2.5-flash-preview-04-17";

const parseGeminiJsonResponse = <T,>(responseText: string, context?: string): T | null => {
  // Guard against responseText not being a string (e.g., undefined if API response was problematic)
  if (typeof responseText !== 'string') {
    const errorContext = context ? ` (Context: ${context})` : '';
    console.error(`Invalid responseText (not a string) received for parsing${errorContext}. Value:`, responseText);
    return null;
  }

  let jsonStr = responseText.trim();
  const fenceRegex = /^```(\w*)?\s*\n?([\s\S]*?)\n?\s*```$/;
  const match = jsonStr.match(fenceRegex);

  if (match && match[2]) {
    jsonStr = match[2].trim();
  }

  try {
    return JSON.parse(jsonStr) as T;
  } catch (error) {
    const errorContext = context ? ` (Context: ${context})` : '';
    // Log the problematic string that failed parsing for easier debugging.
    // Avoid logging the entire original responseText if it's very long.
    const attemptedJsonSnippet = jsonStr.substring(0, 500) + (jsonStr.length > 500 ? "..." : "");
    const originalResponseSnippet = (typeof responseText === 'string' ? responseText.substring(0, 200) : String(responseText)) + (responseText && responseText.length > 200 ? "..." : "");

    console.error(`Failed to parse JSON response${errorContext}:`, error, 
                  "\nAttempted to parse: ", `"${attemptedJsonSnippet}"`,
                  "\nOriginal raw response from API (snippet):", `"${originalResponseSnippet}"`);
    return null;
  }
};

export const generateParaphrases = async (text: string, count: number = 3): Promise<string[]> => {
  if (!process.env.API_KEY) {
    console.error("generateParaphrases: API_KEY environment variable not found.");
    throw new Error("API Key is not configured. Please check server environment variables.");
  }
  if (!text.trim()) return [];

  try {
    const prompt = `You are an expert AI paraphrasing tool.
Paraphrase the following text in ${count} distinct ways.
Maintain the original meaning, tone, and key information.
Ensure each paraphrase is grammatically correct, natural-sounding, **concise**, and ideally **shorter** than the original text.

Original Text: "${text}"

Respond with ONLY a single, valid JSON object formatted as specified below. Do NOT include any explanatory text, markdown formatting for the JSON block (like \`\`\`json\`), or any other content outside of this JSON object.

JSON Format: {
  "paraphrases": ["paraphrase 1", "paraphrase 2", ..., "paraphrase ${count}"]
}`;

    const response: GenerateContentResponse = await ai.models.generateContent({
      model: GEMINI_MODEL,
      contents: prompt,
      config: {
        temperature: 0.7,
      }
    });

    const parsedResponse = parseGeminiJsonResponse<ParaphraseResponse>(response.text, "paraphrasing");
    return parsedResponse?.paraphrases || [];

  } catch (error) {
    console.error(`Error generating paraphrases for "${text.substring(0, 50)}...":`, error);
    return [];
  }
};

export const detectAIGeneratedContent = async (textSnippet: string): Promise<DetectAIContentServiceResult> => {
  if (!process.env.API_KEY) {
    console.error("detectAIGeneratedContent: API_KEY environment variable not found.");
    throw new Error("API Key is not configured.");
  }
  if (!textSnippet.trim()) {
    return { analysis: null };
  }

  try {
    const prompt = `Analyze the following text snippet to determine if it was likely generated by an AI.
Provide your assessment as a JSON object with the following structure:
{
  "isAiGenerated": boolean, // true if likely AI-generated, false otherwise
  "confidenceScore": number, // A value between 0.0 (not confident) and 1.0 (very confident)
  "reasoning": "string" // A brief explanation for your assessment
}

Text Snippet: "${textSnippet}"

Respond with ONLY a single, valid JSON object. Do NOT include any explanatory text or markdown formatting.`;

    const response: GenerateContentResponse = await ai.models.generateContent({
      model: GEMINI_MODEL,
      contents: prompt,
      config: {
        temperature: 0.3, // Lower temperature for more deterministic analysis
      }
    });

    const analysisResult = parseGeminiJsonResponse<AIContentDetectionResult>(response.text, "AI content detection");
    return { analysis: analysisResult };

  } catch (error) {
    console.error(`Error detecting AI-generated content for "${textSnippet.substring(0, 50)}...":`, error);
    return { analysis: null };
  }
};

export const findPlagiarism = async (textSnippet: string): Promise<FindPlagiarismServiceResult> => {
  if (!process.env.API_KEY) {
    console.error("findPlagiarism: API_KEY environment variable not found.");
    throw new Error("API Key is not configured.");
  }
  if (!textSnippet.trim()) {
    return { analysis: null, groundingSources: [] };
  }

  try {
    const prompt = `You are an AI plagiarism detection tool.
Analyze the provided text snippet and compare it against web sources using Google Search to identify potential plagiarism.

Text Snippet: "${textSnippet}"

Respond with ONLY a single, valid JSON object with the following structure. Do NOT include any explanatory text or markdown formatting outside the JSON object.
{
  "overallPlagiarismScore": number, // A score from 0.0 (no plagiarism) to 1.0 (highly plagiarized). This score MUST be a holistic assessment, critically evaluating the number of matches, their similarity scores, and the length of matched segments relative to the input text. A few minor, short, or coincidental matches should result in a low score. Extensive, direct copying should result in a high score.
  "matches": [
    {
      "textSegment": "string", // The specific part of the input text that matches a source
      "sourceUrl": "string", // The VALID and ACCESSIBLE URL of the matched source
      "sourceTitle": "string or null", // The title of the matched source page
      "similarity": number, // A score from 0.0 to 1.0 indicating the similarity
      "justification": "string", // DETAILED explanation why this segment is a match. For example: "Direct copy of 2 sentences from source.", "Paraphrased content with significant overlap in structure and keywords.", "Commonly used phrase, low plagiarism concern despite match.", "Conceptual similarity but different wording."
      "authors": "string or null" // Comma-separated author names, if an academic paper and available on the source page
    }
  ]
}
If no plagiarism is detected, overallPlagiarismScore MUST be 0 and matches MUST be an empty array.
Ensure sourceUrl is a direct link to the content, not a search result page or a broken link.
Provide a DETAILED justification for each match, clearly explaining why it's flagged (e.g., direct quote, structural similarity, specific key phrases matched).
`;

    const response: GenerateContentResponse = await ai.models.generateContent({
      model: GEMINI_MODEL,
      contents: prompt,
      config: {
        tools: [{ googleSearch: {} }],
        temperature: 0.1, // Lower temperature for more factual and precise plagiarism analysis
      }
    });

    const plagiarismResult = parseGeminiJsonResponse<PlagiarismDetectionResult>(response.text, "plagiarism detection");
    
    let groundingSources: WebSource[] = [];
     if (response.candidates && response.candidates.length > 0) {
        const candidate = response.candidates[0] as Candidate; 
        if (candidate.groundingMetadata && candidate.groundingMetadata.groundingChunks) {
            groundingSources = candidate.groundingMetadata.groundingChunks
                .map((chunk: GroundingChunk) => chunk.web) 
                .filter((webSource): webSource is WebSource => webSource !== undefined && webSource.uri !== '');
        }
    }

    return { analysis: plagiarismResult, groundingSources };

  } catch (error)
{
    console.error(`Error finding plagiarism for "${textSnippet.substring(0, 50)}...":`, error);
    return { analysis: null, groundingSources: [] };
  }
};